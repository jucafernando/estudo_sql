-- SQLBook: Markup
## Utilizando a função distinct para selecionar os dados distintos da coluna city. A função distinct é util para retirar os dados duplicados de um dado específico. Por exemplo: Se temos vários compradores de carros na mesma cidade, podemos utilizar o distinct para retornar apenas uma ocorrência de campos que contenham dados da mesma cidade. 
-- SQLBook: Code
 -- Ex 1: Selecione os nomes de cidade distintas que existem no

select distinct city
from sales.customers
where state = 'MG'
order by city
-- SQLBook: Code
--Ex:2 Selecione o visit_id das 10 compras mais recentes efetuadas


select  visit_id 
from sales.funnel 
where paid_date is not null -- filtrando de maneira a não selecionar os dados nulos. 
order by paid_date desc
limit 10
-- SQLBook: Code
-- Ex:3 Selecione todos os dados dos 10 clientes com maior score nascidos

select *
from sales.customers
where birth_date >= '2000-01-01'
order by score desc
limit 10
-- SQLBook: Markup
## Operadores aritméticos 

### Servem para executar operações matemáticos 
### Muito utilizado para criar colunas calculadas
### Alias (pseudôminos/apelidos) são utilizados para dar nomes as colunas calculadas. 
### Para criar alias com espaços, é necessário utilizar aspoas duplas
### No caso de strings, o operador de adição(pipes duplos ||), irá concatenar as strings
-- SQLBook: Code
select
    email,
    birth_date,
    (CURRENT_DATE - birth_date) / 365 as idade
    from sales.customers
-- SQLBook: Markup
## Funções de agregação

### Servem para executar operações aritméticas nos registros de uma coluna 

### As principais são: 

#### MAX(), MIN(), COUNT(), AVG(), SUM()
-- SQLBook: Code
-- Contando todos os produtos distintos visitados em jan/21

select count(DISTINCT product_id)
from sales.funnel
where visit_page_date BETWEEN '2021-01-01' and '2021-01-31'
-- SQLBook: Code
-- calcule o preço minimo, maximo e médio dos produtos da tabela products

select min(price), max(price), avg(price)
from sales.products
-- SQLBook: Code
-- qual o produto mais caro da tabela products


select * from sales.products
where price = (select max(price) 
from sales.products)
-- SQLBook: Code
-- funções de agregação não computam celulas vazias (NULL) como zero
-- pode-se ser usado o count(DISTINCT nome_coluna) para contar uma quantidade exclusiva da coluna que desejar contar. 
-- para verificar outros campos relacionados as colunas dentro de um count(), é necessário realizar uma subquery. 
-- SQLBook: Markup
### Comando GROUP BY

#### Serve para agrupar registros semelhantes de uma coluna 
#### Normalmente utilizado com comandos de agragação (min, max, count, sum)
#### Pode-se referenciar a coluna a ser agrupada pela sua posição ordinal, ex: group by 1,2,3 
#### O group by sozinho funciona como um distinct, eliminando linhas duplicadas. 
-- SQLBook: Code
-- Calcule os clientes por estado e status profissional. Agrupe de maneira correta, deixando o resultado organizado
-- por estado e status profissional. 

select state, professional_status, count(*) as contagem
from sales.customers
--where state = 'SP'
GROUP BY state, professional_status
ORDER BY state, contagem desc
-- SQLBook: Markup
### Função HAVING

#### Serve para filtrar linhas da seleção por uma coluna agrupada
-- SQLBook: Code
select state, count(*)
from sales.customers
--where state <> 'MG'
GROUP BY state 
having count(*) > 100
    and state <> 'MG'
-- SQLBook: Code
-- Conte quantos clientes da tabela sales.customers tem menos de 30 anos

select first_name || ' ' || last_name as nome_completo, birth_date,
(CURRENT_DATE - birth_date) / 365 as idade
from sales.customers
where (CURRENT_DATE - birth_date) / 365 < 30

-- SQLBook: Code
-- Informe a idade do cliente mais velho e mais novo da tabela sales.customers

select 
max(CURRENT_DATE - birth_date) / 365 as mais_velho,
min(CURRENT_DATE - birth_date) / 365 as mais_novo
from sales.customers

-- SQLBook: Code
-- Selecione todas as informações do cliente mais rico da tabela sales.customers
-- (possívelmente a resposta contém mais de um cliente)

SELECT * from sales.customers 
where income = (select max(income) FROM sales.customers)
-- SQLBook: Code
select * from sales.products limit 10
-- SQLBook: Code
-- Conte quantos veículos de cada marca tem registrado na tabela sales.products
-- Ordene o resultado pelo nome da marca

select brand, count(*) 
from sales.products
GROUP BY brand
order by brand
-- SQLBook: Code
-- Conte quantos veículos existem registrados na tabela sales.products
-- por marca e ano do modelo. Ordene pela nome da marca e pelo ano do veículo

select brand, model_year, count(*) as quantidade_veiculos
from sales.products
GROUP BY brand, model_year
order by brand, model_year
-- SQLBook: Code
-- Conte quantos veículos de cada marca tem registrado na tabela sales.products
-- e mostre apenas as marcas que contém mais de 10 veículos registrados

select brand, count(*) 
from sales.products
GROUP BY brand
order by brand
-- SQLBook: Code
-- Identifique quais as marcas de veículo mais visitada na tabela sales.funnel
select * from sales.funnel limit 10


-- SQLBook: Code
-- Identifique quais as lojas de veículo mais visitadas na tabela sales.funnel


select sto.store_id, sto.store_name, count(fun.paid_date) as qtd_visitas
from sales.stores sto
left join sales.funnel fun
on sto.store_id = fun.store_id
where visit_page_date BETWEEN '2021-08-01' and '2021-08-31'
GROUP BY 1,2
-- SQLBook: Code
-- Identifique quantos clientes moram em cada tamanho de cidade (o porte da cidade
-- consta na coluna "size" da tabela temp_tables.regions)
-- SQLBook: Markup
### Subquery:
#### Servem para consultar dados de outras consultas 
#### Para que as subqueries no Where e no select funcionem, elas devem retornar apenas um unico valor
#### Não é recomendado utilizar subqueries diretamente dentro do FROM 
#### pois isso dificulta a legibilidade da query. 
-- SQLBook: Code
-- (Exemplo 1) Subquery no WHERE
-- Informe qual é o veículo mais barato da tabela products

select *
from sales.products
where price = (select min(price) from sales.products)
-- SQLBook: Code
-- (Exemplo 2) Subquery com WITH
-- Calcule a idade média dos clientes por status profissional
with alguma_tabela as (
select
	professional_status,
	(current_date - birth_date)/365 as idade
from sales.customers
)

select
	professional_status,
	avg(idade) as idade_media
from alguma_tabela
group by professional_status
-- SQLBook: Code
-- (Exemplo 3) Subquery no FROM
-- Calcule a média de idades dos clientes por status profissional
-- O resultado é o mesmo mas utilizar subqueries através do FROM, é bem mais demorado do que fazer 
-- uma subquerie com with por exemplo. 

select
	professional_status,
	avg(idade) as idade_media
from (
		select
			professional_status,
			(current_date - birth_date)/365 as idade
		from sales.customers
	 ) as alguma_tabela
group by professional_status
-- SQLBook: Code
-- (Exemplo 4) Subquery no SELECT
-- Na tabela sales.funnel crie uma coluna que informe o nº de visitas acumuladas 
-- que a loja visitada recebeu até o momento

select
	fun.visit_id,
	fun.visit_page_date,
	sto.store_name,
	(
		select count(*)
		from sales.funnel as fun2
		where fun2.visit_page_date <= fun.visit_page_date
			and fun2.store_id = fun.store_id
	) as visitas_acumuladas
from sales.funnel as fun
left join sales.stores as sto
	on fun.store_id = sto.store_id
order by sto.store_name, fun.visit_page_date
-- SQLBook: Markup
## Tratamento de texto
### LOWER() é utilizado para transformar todo texto em letras minúsculas
### UPPER() é utilizado para transformar todo texto em letras maiúsculas
### TRIM() é utilizado para remover os espaços das extremidades de um texto
### REPLACE() é utilizado para substituir uma string por outra string
-- SQLBook: Code
-- Corrija o primeiro elemento das queries abaixo utilizando os comandos 
-- de tratamento de texto para que o resultado seja sempre TRUE 

select 'São Paulo' = 'SÃO PAULO'
select upper('São Paulo') = 'SÃO PAULO'


select 'São Paulo' = 'são paulo'
select lower('São Paulo') = 'são paulo'


select 'SÃO PAULO     ' = 'SÃO PAULO'
select trim('SÃO PAULO     ') = 'SÃO PAULO'


select 'SAO PAULO' = 'SÃO PAULO'
select replace('SAO PAULO', 'SAO', 'SÃO') = 'SÃO PAULO'
-- SQLBook: Markup
## Tratamento de dados de data e hora
### O comando INTERVAL é utilizado para somar datas na unidade desejada. Caso a 
### unidade não seja informada, o SQL irá entender que a soma foi feita em dias.
### O comando DATE_TRUNC é utilizado para truncar uma data no início do período
### O comando EXTRACT é utilizado para extrair unidades de uma data/timestamp
### O cálculo da diferença entre datas com o operador de subtração (-) retorna  
### valores em dias. Para calcular a diferença entre datas em outra unidade é necessário
### fazer uma transformação de unidades (ou criar uma função para isso)
-- SQLBook: Code
-- (Exemplo 1) Soma de datas utilizando INTERVAL
-- Calcule a data de hoje mais 10 unidades (dias, semanas, meses, horas)

select current_date + 10
select (current_date + interval '10 weeks')::date
select (current_date + interval '10 months')::date
select current_date + interval '10 hours'
-- SQLBook: Code
-- (Exemplo 2) Truncagem de datas utilizando DATE_TRUNC
-- Calcule quantas visitas ocorreram por mês no site da empresa

select visit_page_date, count(*)
from sales.funnel
group by visit_page_date
order by visit_page_date desc

select
	date_trunc('month', visit_page_date)::date as visit_page_month,
	count(*)
from sales.funnel
group by visit_page_month
order by visit_page_month desc

-- SQLBook: Code
-- (Exemplo 3) Extração de unidades de uma data utilizando EXTRACT
-- Calcule qual é o dia da semana que mais recebe visitas ao site


select
	extract('dow' from visit_page_date) as dia_da_semana,
	count(*) 
from sales.funnel
group by dia_da_semana
order by dia_da_semana

-- SQLBook: Code
-- (Exemplo 4) Diferença entre datas com operador de subtração (-) 
-- Calcule a diferença entre hoje e '2018-06-01', em dias, semanas, meses e anos.

select (current_date - '2018-06-01')
select (current_date - '2018-06-01')/7
select (current_date - '2018-06-01')/30
select (current_date - '2018-06-01')/365

select datediff('weeks', '2018-06-01', current_date)

-- SQLBook: Markup
## Criando funções no SQL
### Para criar funções, utiliza-se o comando CREATE FUNCTION
### Para que o comando funcione é obrigatório informar (a)- quais as unidades dos 
### INPUTS (b)- quais as unidades dos OUTPUTS e (c)- em qual linguagem a função será escrita
### O script da função deve estar delimitado por $$
### Para deletar uma função utiliza-se o comando DROP FUNCTION
-- SQLBook: Code
-- (Exemplo 1) Crie uma função chamada DATEDIFF para calcular a diferença entre
-- duas datas em dias, semanas, meses, anos

select (current_date - '2018-06-01')
select (current_date - '2018-06-01')/7
select (current_date - '2018-06-01')/30
select (current_date - '2018-06-01')/365

select datediff('weeks', '2018-06-01', current_date)

create function datediff(unidade varchar, data_inicial date, data_final date)
returns integer
language sql

as

$$

	select
		case
			when unidade in ('d', 'day', 'days') then (data_final - data_inicial)
			when unidade in ('w', 'week', 'weeks') then (data_final - data_inicial)/7
			when unidade in ('m', 'month', 'months') then (data_final - data_inicial)/30
			when unidade in ('y', 'year', 'years') then (data_final - data_inicial)/365
			end as diferenca

$$

select datediff('years', '2021-02-04', current_date)
-- SQLBook: Code
-- Delete a função DATEDIFF criada no exercício anterior

delete FUNCTION nome_funcao
-- SQLBook: Markup
## Criação e deleção de tabelas 

### Para criar tabelas a partir de uma query basta escrever a query normalmente e
### colocar o comando INTO antes do FROM informando o schema e o nome da tabela 
### a ser criada
### Para criar tabelas a partir do zero é necessário (a) criar uma tabela vazia 
### com o comando CREATE TABLE (b) Informar que valores serão inseridos com o comando
### INSERT INTO seguido do nome das colunas (c) Inserir os valores manualmente em forma 
### de lista após o comando VALUES
### Para deletar uma tabela utiliza-se o comando DROP TABLE
-- SQLBook: Code
-- Criação de tabela a partir de uma query
-- Crie uma tabela chamada customers_age com o id e a idade dos clientes. 
-- Chame-a de temp_tables.customers_age

select
	customer_id,
	datediff('years', birth_date, current_date) idade_cliente
	into temp_tables.customers_age
from sales.customers

select *
from temp_tables.customers_age
-- SQLBook: Code
-- Criação de tabela a partir do zero
-- Crie uma tabela com a tradução dos status profissionais dos clientes. 
-- Chame-a de temp_tables.profissoes

select distinct professional_status
from sales.customers

create table temp_tables.profissoes (
	professional_status varchar,
	status_profissional varchar
)

insert into temp_tables.profissoes
(professional_status, status_profissional)

values
('freelancer', 'freelancer'),
('retired', 'aposentado(a)'),
('clt', 'clt'),
('self_employed', 'autônomo(a)'),
('other', 'outro'),
('businessman', 'empresário(a)'),
('civil_servant', 'funcionário público(a)'),
('student', 'estudante')

select * from temp_tables.profissoes
-- SQLBook: Code
-- Deleção de tabelas
-- Delete a tabela temp_tables.profissoes

drop table temp_tables.profissoes

-- SQLBook: Code

-- Crie uma coluna calculada com o número de visitas realizadas por cada
-- cliente da tabela sales.customers

with numero_de_visitas as (

	select customer_id, count(*) as n_visitas
	from sales.funnel
	group by customer_id

)

select
	cus.*,
	n_visitas

from sales.customers as cus
left join numero_de_visitas as ndv
	on cus.customer_id = ndv.customer_id
-- SQLBook: Code
-- (Query 5) Dias da semana com maior número de visitas ao site
-- Colunas: dia_semana, dia da semana, visitas (#)


    
    select
	extract('dow' from visit_page_date) as dia_semana,
    CASE 
        WHEN extract('dow' from visit_page_date)=0 then 'domingo' 
        WHEN extract('dow' from visit_page_date)=1 then 'segunda'
        WHEN extract('dow' from visit_page_date)=2 then 'terca'
        WHEN extract('dow' from visit_page_date)=3 then 'quarta'
        WHEN extract('dow' from visit_page_date)=4 then 'quinta'
        WHEN extract('dow' from visit_page_date)=5 then 'sexta'
        WHEN extract('dow' from visit_page_date)=6 then 'sabado'
        else null end as "dia da semana",
    count(*) as "visitas"
	from sales.funnel
    where visit_page_date between '2021-08-01' and '2021-08-31' 
    group by dia_semana
    order by dia_semana

-- SQLBook: Code
-- Lojas que mais venderam
-- Colunas: loja, vendas (#)

select sto.store_name as "loja", count(fun.paid_date) as "vendas" 
from sales.stores sto
left join sales.funnel fun
on sto.store_id = fun.store_id
where paid_date BETWEEN '2021-08-01' and '2021-08-31'
GROUP BY loja
ORDER BY vendas desc limit 5
-- SQLBook: Code
-- Marcas que mais venderam no mês
-- Colunas: marca, vendas (#)


select prod.brand as "marca", count(fun.paid_date) as "vendas"
from sales.products prod
left join sales.funnel fun
on prod.product_id = fun.product_id
where paid_date BETWEEN '2021-08-01' and '2021-08-31'
GROUP BY 1
ORDER BY vendas DESC LIMIT 5
-- SQLBook: Code
-- estados que mais venderam
select 'Brazil' as "país", state, count(fun.paid_date) as "vendas"
from sales.funnel fun
left join sales.customers cust
on fun.customer_id = cust.customer_id
where paid_date BETWEEN '2021-08-01' and '2021-08-31'
GROUP BY país,state
ORDER BY vendas desc limit 5
-- SQLBook: Code
select state,count(*) from sales.customers
GROUP BY 1

-- SQLBook: Code
SELECT * FROM SALES.products 
-- SQLBook: Code
-- Receita, leads, conversão e ticket médio mês a mês
-- Colunas: mês, leads (#), vendas (#), receita (k, R$), conversão (%), ticket médio (k, R$)

with data_visitas as (
	select
		date_trunc('month', visit_page_date)::date as visit_page_month,
		count(*) as visit_count
	from sales.funnel
	GROUP BY visit_page_month
	order by visit_page_month
	),

	payments as (
	select 
		date_trunc('month', fun.visit_page_date)::date as page_month,
		count(fun.paid_date) as paid_count,
		sum(prod.price * (1+fun.discount)) as receita
	from sales.funnel fun
	left join sales.products prod
		ON fun.product_id = prod.product_id
	where fun.paid_date is NOT NULL
	group by page_month
	order by page_month	
	)

select 
	data_visitas.visit_page_month as "mes",
	data_visitas.visit_count as "leads", 
	payments.paid_count as "vendas",
	(payments.receita/1000) as "receita (k, R$)",
	(payments.paid_count::float/data_visitas.visit_count::float) as "conversão %",
	(payments.receita/payments.paid_count/1000) as "ticket médio (k, R$)"
from data_visitas 
left join payments 
	on data_visitas.visit_page_month = page_month




-- SQLBook: Code
select * from sales.funnel limit 10